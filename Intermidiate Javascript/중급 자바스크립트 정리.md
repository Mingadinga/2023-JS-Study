# 호이스팅
영상만으로는 명쾌한 이해가 어려워서 구글링을 하다가 [좋은 글](https://tecoble.techcourse.co.kr/post/2021-04-25-hoisting/)을 발견하여 참고했다.

## 호이스팅이란?
호이스팅은 **변수, 함수의 선언부가 위치한 인접 스코프의 시작 지점에서 해당 식별자의 관측이 가능한 현상**이다. 실행 시점으로 넘어가기 전에 선언된 식별자에 대한 정보를 이미 알고 있기 때문에 스코프의 어느 지점이든 관련된 함수나 변수를 참조할 수 있다. 선언 전에 사용하는 코드가 정상 동작한다. (충격)
```javascript
console.log(name);
var name = 'Mike';
```

## 호이스팅 규칙
함수/변수에 따라 다른 규칙이 적용된다.
1. 선언된 함수는 상단에서 참조, 호출이 가능하다.
2. 선언된 var 는 상단에서 참조, 할당이 가능하다.
3. 선언된 let , const 는 상단에서 참조, 할당이 불가능하다.


## 함수 호이스팅

함수 선언식은 식별자가 수집될 때 함수 참조에 대한 초기화까지 자동으로 이루어진다. 그래서 선언된 함수는 상단에서 참조, 호출이 가능하다.
```javascript
output1(); // output : jung min
function output1() {
	console.log('jung min');
}
```

함수 표현식은 결국 함수를 변수에 할당하는 것이므로 변수 호이스팅 사례로 볼 수 있다.
아래 에제에서는 output1에 메모리는 할당되었지만 값이 undefined이므로 TypeError가 발생했다.
output1에 함수를 할당하여 초기화하고 호출하면 정상 작동한다.
```javascript
output1(); // Uncaught TypeError: output1 is not a function
var output1 = function() {
	console.log('jung min');
}
```


## 변수 호이스팅

변수는 다음과 같이 세 가지 단계를 거쳐 사용된다.
1. 선언 : 파싱 과정에서 변수 객체가 변수에 대한 식별자를 수집한다.
2. 초기화 : 식별자에 메모리를 할당하고 undefined 상태를 부여한다.
3. 할당 : 변수에 직접 값을 할당한다.

var과 let, const는 호이스팅이 발생하는 시점에 다른 현상이 발생한다.
1. var : 호이스팅이 발생하면 선언과 초기화가 거의 동시에 발생한다. 스코프 상단에서 메모리가 할당되어 있으므로 참조(undefined 상태)와 할당이 가능하다.
2. let, const : 호이스팅이 발생하면 선언만 이루어지고 초기화가 이루어지지 않는다. 변수에 값을 직접 초기화하는 코드를 읽을 때까지 메모리가 할당되지 않기 때문에, 스코프 시작 부분과 실질적 선언부 부분 사이에 간극이 존재한다. 이 부분을 TDZ(Temporal Dead Zone)이라고 한다.

```javascript
{
  /*
   * Temporal Dead Zone of a
   * a는 이 구간에서 참조할 수 없다.
   * console.log(a) // Reference Error
   */
  let a;
}
```


# 생성자
기초 강의에서는 객체 리터럴을 이용해 객체를 생성했다.

```jsx
const superman = {
    name : 'clark',
    age : 30,
}

console.log(superman.name)
console.log(superman['name'])
console.log(superman)
```

객체 리터럴은 모든 객체의 조상인 Object에 키와 프로퍼티가 추가된 형태이다. Object 객체에 키와 프로퍼티를 추가한 객체이므로 그 자체로 유일하다. 객체 리터럴 방식으로 생성된 객체는 같은 형태의 객체를 재생성할 수 없다.

자바나 C++처럼 객체의 원형을 두고 찍어내는 방식으로 객체를 생성하려면 생성자 함수를 사용한다. 자바스크립트에는 클래스가 없기 때문에 기존 함수에 new 연산자를 붙여 호출하면 그 함수가 생성자 함수로 동작한다.

```jsx
function Item(title, price) {
    // this = {};
    this.title = title;
    this.price = price;
    this.showPrice = function() {
        console.log(`가격은 ${price}원 입니다.`);
    }
    // return this
}

const item1 = new Item('인형', 3000);
const item2 = new Item('가방', 2000);
const item3 = new Item('지갑', 4000);

console.log(item1, item2, item3);
item3.showPrice();
```

생성자 함수를 호출해서 Item 타입의 객체들을 생성할 수 있다.

객체 리터럴 방식과 생성자 방식의 차이점을 자세하게 알려면 자바스크립트의 프로토타입을 이해해야한다. 하지만 뒷부분에 프로토타입 설명이 나오기 때문에 지금은 생략하지만, 간단히 애기하면 객체 리터럴 방식의 prototype 프로퍼티는 Object, 생성자 함수 방식은 자신의 프로토타입 객체이다. **지금 기억해야할 것은 객체 리터럴 방식과 생성자 방식을 사용하는 방법의 차이점이 객체의 재생성 가능 여부라는 것이다.**

# 연산 프로퍼티
객체의 키로 고정된 값이 아닌 변수의 값을 지정할 수 있다.

```jsx
let a = 'age';

const user = {
	name: 'Mike',
	[a]: 30
}
```

```jsx
const user = {
	[1 + 4]: 5,
	["안녕"+"하세요"]: "Hello"
}
```

# Object Method
- `Object.assign()` : 객체 복사
- `Object.keys()` : 객체의 키 배열 반환
- `Object.values()` : 객체의 값 배열 반환
- `Object.entries()` : 객체의 키와 값 쌍을 배열로 반환
- `Object.fromEntries()` : 키와 값 배열을 객체로 변환

> 객체 복사
> 

```jsx
const user = {
	name: 'Mike',
	age: 30
}

// 참조값 복사
const user2 = user; 

// 복사
const newUser = Object.assign({}, user); 
newUser.name = 'Tom';
console.log(user.name); // 'Mike'

// 초기값과 병합
const maleUser = Object.assign({gender: 'Male'}, user);
console.log(maleUser.gender); // 'Male'

// 덮어쓰기
const tomUser = Object.assign({name: 'Tom'}, user);
console.log(tomUser.name); // 'Tom'

// 객체 병합 복사
const user = {
	name: 'Mike'
}
const info1 = {
	age: 30,
}
const info2 = {
	gender: 'male',
}

Object.assign(user, info1, info2);
```

> 키, 값, 키값 쌍 배열 반환
> 

```jsx
const user = {
	name: 'Mike',
	age: 30,
	gender: 'male'
}

Object.keys(user); // ["name", "age", "gender"]
Object.values(user); // ["Mike", 30, "male"]
Object.entries(user); // [["name", "Mike"], ["age", 30], ["gender", "male"]]
```

> 키값 배열을 객체로
> 

```jsx
const arr = [
	["name", "Mike"], 
	["age", 30], 
	["gender", "male"]
]

Object.fromEntries(arr);

/*
{
	name: 'Mike',
	age: 30,
	gender: 'male',
}
*/
```

# Symbol

객체의 키는 보통 문자열로 취급된다. 하지만 문자열 키는 그 문자열의 값이 동일하면 구별할 수 없다. 이런 문제를 해결하고자 **유일한 식별자인 Symbol 클래스를 키로 사용**한다.

```jsx
// 유일한 식별자를 제공하는 Symbol
const a = Symbol();
const b = Symbol();

console.log(a);
Symbol();

console.log(b);
Symbol();

a === b; // false
a == b; // false
```

Symbol 클래스는 반복문으로 객체 프로퍼티를 순회했을 때 보이지 않는다.

```jsx
const id = Symbol('id');
const user = {
	name: 'Mike',
	age: 30,
	[id]: 'myid'
}
user // {name: "Mike", age: 30, Symbol(id): "myid"}
user[id] // 'myid'

Object.keys(user); // ["name", "age"]
Object.values(user); // ["Mike", 30]
Object.entries(user); // [Array(2), Array(2)]
for(let a in user) {} 
```

사용 이유 : **특정 객체의 원본을 건드리지 않고 자신만의 속성을 추가해서 사용할 수 있다. 기존 객체와 코드에 영향을 미치지 않음을 보장한다.**

```jsx
// 기존 객체
const user = {
	name: 'Mike',
	age: 30,
}

// 속성 추가
const id = Symbol.for('id');
user[id] = 'myid';

// 기존 객체의 프로퍼티로만 순회
for(let key in user) {
	console.log(`His ${key} id ${user[key]}.`);
}
```

전역변수처럼 이름이 같으면 같은 객체를 가리켜야할 때가 있는데, Symbol.for()을 사용하면 전역 심볼을 가져올 수 있다. 싱글톤 패턴을 사용한다.

```jsx
const id1 = Symbol.for('id');
const id2 = Symbol.for('id');

id1 == id2; // true
Symbol.keyFor(id1); // "id"
id.description; // "id"
```

숨겨진 Symbol Key를 확인할 수 있다. 하지만 대부분의 라이브러리는 이런 메소드를 사용하지 않는다. 그러니 유일한 키를 추가하고 싶을 때 걱정하지 않고 사용할 수 있다.

```jsx
const id = Symbol.for('id');
const user = {
	name: 'Mike',
	age: 30,
	[id]: 'myid'
};

Object.getOwnPropertySymbols(user); // Symbol(id)
Reflect.ownKeys(user); // ["name", "age", Symbol(id)]
```

# Math

> toString() : 숫자를 문자로

```jsx
let num = 10;
num.toString(); // "10"
num.toString(2); // "1010"

let num2 = 255;
num2.toString(16); // "ff"
```

> ceil() : 올림

```jsx
let s1 = 5.1;
let s2 = 5.7;
Math.ceil(s1); // 6
Math.ceil(s2); // 6
```

> floor() : 내림

```jsx
Math.floor(s1); // 5
Math.floor(s2); // 5
```

> round() : 반올림

```jsx
Math.round(s1);
Math.round(s2);
```

> toPrefix() : 소수점 자릿수까지 반올림하여 문자열 반환

```jsx
let userRate = 30.12345;
userRate.toFixed(2); // "30.12"
userRate.toFixed(6); // "30.123450"
```

> Number() : 문자열을 숫자로 변환

```jsx
Number(userRate.toFixed(2)); // 30.12
```

> isNaN(): NaN인지 검사

```jsx
let x = Number('x'); // NaN
x == NaN // false
isNaN(x) // true
```

> parseInt() : 문자가 포함된 숫자 문자열도 숫자로 변환, 읽을 수 있는 곳까지

```jsx
let margin = '10px';
parseInt(margin); // 10
Number(margin); // NaN

let redColor = 'f3';
parseInt(redColor); // NaN
parseInt(redColor, 16); // 243
```


> parseFloat() : 문자가 포함된 소수 문자열도 소수로 변환, 부동소수점 사용

```jsx
let padding = '18.5%';
parseInt(padding); // 18
parseFloat(padding); // 18.5
```


> random() : [0, 1) 소수 뽑기

```jsx
Math.floor(Math.random() * 100) + 1 // 1 ~ 100
```

> max(), min()

```jsx
Math.max([1, 4, 5, 2, 4]); // 5
Math.min([1, 4, 5, 2, 4]); // 1
```

> abs() : 절대값

```jsx
Math.abs(-1) // 1
```

> pow(n, m) : n^m

```jsx
Math.pow(2, 10); // 1024
```

> sqrt() : 제곱근

```jsx
Math.sqrt(16);
```