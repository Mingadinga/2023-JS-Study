# 호이스팅
영상만으로는 명쾌한 이해가 어려워서 구글링을 하다가 [좋은 글](https://tecoble.techcourse.co.kr/post/2021-04-25-hoisting/)을 발견하여 참고했다.

## 호이스팅이란?
호이스팅은 **변수, 함수의 선언부가 위치한 인접 스코프의 시작 지점에서 해당 식별자의 관측이 가능한 현상**이다. 실행 시점으로 넘어가기 전에 선언된 식별자에 대한 정보를 이미 알고 있기 때문에 스코프의 어느 지점이든 관련된 함수나 변수를 참조할 수 있다. 선언 전에 사용하는 코드가 정상 동작한다. (충격)
```javascript
console.log(name);
var name = 'Mike';
```

## 호이스팅 규칙
함수/변수에 따라 다른 규칙이 적용된다.
1. 선언된 함수는 상단에서 참조, 호출이 가능하다.
2. 선언된 var 는 상단에서 참조, 할당이 가능하다.
3. 선언된 let , const 는 상단에서 참조, 할당이 불가능하다.


## 함수 호이스팅

함수 선언식은 식별자가 수집될 때 함수 참조에 대한 초기화까지 자동으로 이루어진다. 그래서 선언된 함수는 상단에서 참조, 호출이 가능하다.
```javascript
output1(); // output : jung min
function output1() {
	console.log('jung min');
}
```

함수 표현식은 결국 함수를 변수에 할당하는 것이므로 변수 호이스팅 사례로 볼 수 있다.
아래 에제에서는 output1에 메모리는 할당되었지만 값이 undefined이므로 TypeError가 발생했다.
output1에 함수를 할당하여 초기화하고 호출하면 정상 작동한다.
```javascript
output1(); // Uncaught TypeError: output1 is not a function
var output1 = function() {
	console.log('jung min');
}
```


## 변수 호이스팅

변수는 다음과 같이 세 가지 단계를 거쳐 사용된다.
1. 선언 : 파싱 과정에서 변수 객체가 변수에 대한 식별자를 수집한다.
2. 초기화 : 식별자에 메모리를 할당하고 undefined 상태를 부여한다.
3. 할당 : 변수에 직접 값을 할당한다.

var과 let, const는 호이스팅이 발생하는 시점에 다른 현상이 발생한다.
1. var : 호이스팅이 발생하면 선언과 초기화가 거의 동시에 발생한다. 스코프 상단에서 메모리가 할당되어 있으므로 참조(undefined 상태)와 할당이 가능하다.
2. let, const : 호이스팅이 발생하면 선언만 이루어지고 초기화가 이루어지지 않는다. 변수에 값을 직접 초기화하는 코드를 읽을 때까지 메모리가 할당되지 않기 때문에, 스코프 시작 부분과 실질적 선언부 부분 사이에 간극이 존재한다. 이 부분을 TDZ(Temporal Dead Zone)이라고 한다.

```javascript
{
  /*
   * Temporal Dead Zone of a
   * a는 이 구간에서 참조할 수 없다.
   * console.log(a) // Reference Error
   */
  let a;
}
```


# 생성자
기초 강의에서는 객체 리터럴을 이용해 객체를 생성했다.

```jsx
const superman = {
    name : 'clark',
    age : 30,
}

console.log(superman.name)
console.log(superman['name'])
console.log(superman)
```

객체 리터럴은 모든 객체의 조상인 Object에 키와 프로퍼티가 추가된 형태이다. Object 객체에 키와 프로퍼티를 추가한 객체이므로 그 자체로 유일하다. 객체 리터럴 방식으로 생성된 객체는 같은 형태의 객체를 재생성할 수 없다.

자바나 C++처럼 객체의 원형을 두고 찍어내는 방식으로 객체를 생성하려면 생성자 함수를 사용한다. 자바스크립트에는 클래스가 없기 때문에 기존 함수에 new 연산자를 붙여 호출하면 그 함수가 생성자 함수로 동작한다.

```jsx
function Item(title, price) {
    // this = {};
    this.title = title;
    this.price = price;
    this.showPrice = function() {
        console.log(`가격은 ${price}원 입니다.`);
    }
    // return this
}

const item1 = new Item('인형', 3000);
const item2 = new Item('가방', 2000);
const item3 = new Item('지갑', 4000);

console.log(item1, item2, item3);
item3.showPrice();
```

생성자 함수를 호출해서 Item 타입의 객체들을 생성할 수 있다.

객체 리터럴 방식과 생성자 방식의 차이점을 자세하게 알려면 자바스크립트의 프로토타입을 이해해야한다. 하지만 뒷부분에 프로토타입 설명이 나오기 때문에 지금은 생략하지만, 간단히 애기하면 객체 리터럴 방식의 prototype 프로퍼티는 Object, 생성자 함수 방식은 자신의 프로토타입 객체이다. **지금 기억해야할 것은 객체 리터럴 방식과 생성자 방식을 사용하는 방법의 차이점이 객체의 재생성 가능 여부라는 것이다.**

# 연산 프로퍼티
객체의 키로 고정된 값이 아닌 변수의 값을 지정할 수 있다.

```jsx
let a = 'age';

const user = {
	name: 'Mike',
	[a]: 30
}
```

```jsx
const user = {
	[1 + 4]: 5,
	["안녕"+"하세요"]: "Hello"
}
```

# Object Method
- `Object.assign()` : 객체 복사
- `Object.keys()` : 객체의 키 배열 반환
- `Object.values()` : 객체의 값 배열 반환
- `Object.entries()` : 객체의 키와 값 쌍을 배열로 반환
- `Object.fromEntries()` : 키와 값 배열을 객체로 변환

> 객체 복사
> 

```jsx
const user = {
	name: 'Mike',
	age: 30
}

// 참조값 복사
const user2 = user; 

// 복사
const newUser = Object.assign({}, user); 
newUser.name = 'Tom';
console.log(user.name); // 'Mike'

// 초기값과 병합
const maleUser = Object.assign({gender: 'Male'}, user);
console.log(maleUser.gender); // 'Male'

// 덮어쓰기
const tomUser = Object.assign({name: 'Tom'}, user);
console.log(tomUser.name); // 'Tom'

// 객체 병합 복사
const user = {
	name: 'Mike'
}
const info1 = {
	age: 30,
}
const info2 = {
	gender: 'male',
}

Object.assign(user, info1, info2);
```

> 키, 값, 키값 쌍 배열 반환
> 

```jsx
const user = {
	name: 'Mike',
	age: 30,
	gender: 'male'
}

Object.keys(user); // ["name", "age", "gender"]
Object.values(user); // ["Mike", 30, "male"]
Object.entries(user); // [["name", "Mike"], ["age", 30], ["gender", "male"]]
```

> 키값 배열을 객체로
> 

```jsx
const arr = [
	["name", "Mike"], 
	["age", 30], 
	["gender", "male"]
]

Object.fromEntries(arr);

/*
{
	name: 'Mike',
	age: 30,
	gender: 'male',
}
*/
```

# Symbol

객체의 키는 보통 문자열로 취급된다. 하지만 문자열 키는 그 문자열의 값이 동일하면 구별할 수 없다. 이런 문제를 해결하고자 **유일한 식별자인 Symbol 클래스를 키로 사용**한다.

```jsx
// 유일한 식별자를 제공하는 Symbol
const a = Symbol();
const b = Symbol();

console.log(a);
Symbol();

console.log(b);
Symbol();

a === b; // false
a == b; // false
```

Symbol 클래스는 반복문으로 객체 프로퍼티를 순회했을 때 보이지 않는다.

```jsx
const id = Symbol('id');
const user = {
	name: 'Mike',
	age: 30,
	[id]: 'myid'
}
user // {name: "Mike", age: 30, Symbol(id): "myid"}
user[id] // 'myid'

Object.keys(user); // ["name", "age"]
Object.values(user); // ["Mike", 30]
Object.entries(user); // [Array(2), Array(2)]
for(let a in user) {} 
```

사용 이유 : **특정 객체의 원본을 건드리지 않고 자신만의 속성을 추가해서 사용할 수 있다. 기존 객체와 코드에 영향을 미치지 않음을 보장한다.**

```jsx
// 기존 객체
const user = {
	name: 'Mike',
	age: 30,
}

// 속성 추가
const id = Symbol.for('id');
user[id] = 'myid';

// 기존 객체의 프로퍼티로만 순회
for(let key in user) {
	console.log(`His ${key} id ${user[key]}.`);
}
```

전역변수처럼 이름이 같으면 같은 객체를 가리켜야할 때가 있는데, Symbol.for()을 사용하면 전역 심볼을 가져올 수 있다. 싱글톤 패턴을 사용한다.

```jsx
const id1 = Symbol.for('id');
const id2 = Symbol.for('id');

id1 == id2; // true
Symbol.keyFor(id1); // "id"
id.description; // "id"
```

숨겨진 Symbol Key를 확인할 수 있다. 하지만 대부분의 라이브러리는 이런 메소드를 사용하지 않는다. 그러니 유일한 키를 추가하고 싶을 때 걱정하지 않고 사용할 수 있다.

```jsx
const id = Symbol.for('id');
const user = {
	name: 'Mike',
	age: 30,
	[id]: 'myid'
};

Object.getOwnPropertySymbols(user); // Symbol(id)
Reflect.ownKeys(user); // ["name", "age", Symbol(id)]
```

# Math

> toString() : 숫자를 문자로

```jsx
let num = 10;
num.toString(); // "10"
num.toString(2); // "1010"

let num2 = 255;
num2.toString(16); // "ff"
```

> ceil() : 올림

```jsx
let s1 = 5.1;
let s2 = 5.7;
Math.ceil(s1); // 6
Math.ceil(s2); // 6
```

> floor() : 내림

```jsx
Math.floor(s1); // 5
Math.floor(s2); // 5
```

> round() : 반올림

```jsx
Math.round(s1);
Math.round(s2);
```

> toPrefix() : 소수점 자릿수까지 반올림하여 문자열 반환

```jsx
let userRate = 30.12345;
userRate.toFixed(2); // "30.12"
userRate.toFixed(6); // "30.123450"
```

> Number() : 문자열을 숫자로 변환

```jsx
Number(userRate.toFixed(2)); // 30.12
```

> isNaN(): NaN인지 검사

```jsx
let x = Number('x'); // NaN
x == NaN // false
isNaN(x) // true
```

> parseInt() : 문자가 포함된 숫자 문자열도 숫자로 변환, 읽을 수 있는 곳까지

```jsx
let margin = '10px';
parseInt(margin); // 10
Number(margin); // NaN

let redColor = 'f3';
parseInt(redColor); // NaN
parseInt(redColor, 16); // 243
```


> parseFloat() : 문자가 포함된 소수 문자열도 소수로 변환, 부동소수점 사용

```jsx
let padding = '18.5%';
parseInt(padding); // 18
parseFloat(padding); // 18.5
```


> random() : [0, 1) 소수 뽑기

```jsx
Math.floor(Math.random() * 100) + 1 // 1 ~ 100
```

> max(), min()

```jsx
Math.max([1, 4, 5, 2, 4]); // 5
Math.min([1, 4, 5, 2, 4]); // 1
```

> abs() : 절대값

```jsx
Math.abs(-1) // 1
```

> pow(n, m) : n^m

```jsx
Math.pow(2, 10); // 1024
```

> sqrt() : 제곱근

```jsx
Math.sqrt(16);
```


# Array

## 배열 관련 기능

- splice(n, m, k)
- slice(n, m)
- concat(arr1, arr2, … )
- forEach(fn)
- indexOf(item, start)
- lastIndexOf(item)
- includes(item)
- find(fn)
- findIndex(fn)
- reverse()
- filter(fn)
- map(fn)
- join(sep)
- split(sep)
- isArray(obj)
- sort(fn), Lodash 라이브러리
- reduce(fn)

## splice(n, m, k)

[n, m) 인덱스의 요소를 원본으로부터 제거하여 반환한다. 여러개의 k로 제거 후 요소를 추가할 수 있다.

```jsx
// 제거
let arr = [1, 2, 3, 4, 5];
let result = arr.splice(1, 3, 100, 200);
console.log(arr); // [ 1, 100, 200, 5 ]
console.log(result); // [ 2, 3 ]

// 제거하고 추가
arr = ["나는", "철수", "입니다"];
arr.splice(1, 0, "대한민국", "소방관");
console.log(arr); // [ '나는', '대한민국', '소방관', '철수', '입니다' ]
```

## slice(n, m)

[n, m)까지 반환한다. 원본 배열은 바뀌지 않는다.

```jsx
let arr = [1, 2, 3, 4, 5];
console.log(arr.slice(1, 4)); // [ 2, 3, 4 ]

// 배열 복사
let arr2 = arr.slice();
console.log(arr2); // [ 1, 2, 3, 4, 5 ]
```

## concat(arr1, arr2, … )

합쳐서 새 배열을 반환한다.

```jsx
let arr = [1, 2];
console.log(arr.concat([3, 4])); // [ 1, 2, 3, 4 ]
console.log(arr.concat(1, 4)); // [ 1, 2, 1, 4 ]
console.log(arr.concat([3, 4], 5, 6)); // [ 1, 2, 3, 4, 5, 6 ]
```

## forEach(fn)

배열을 반복한다. 각 아이템에 대해 value, index, arr(원본 배열)을 받을 수 있다.

```jsx
let users = ['Mike', 'Tom', 'Jane'];
users.forEach((name, index) => {
    console.log(`${index + 1}. ${name}`);
})
/*
1. Mike
2. Tom
3. Jane
*/
```

## indexOf(item, start) / lastIndexOf(item)

start부터 item을 탐색하고 인덱스를 반환한다. start의 디폴트 값은 0이다. lastIndexOf는 끝에서부터 값을 찾아 인덱스를 반환한다.

```jsx
let arr = [1, 2, 3, 4, 5, 1, 2, 3];
arr.indexOf(3); // 2
arr.indexOf(3, 3); // 7
arr.lastIndexOf(3); // 7
```

## includes(item)

아이템을 포함하는지 확인한다. 주로 기본 자료형을 찾을 때 사용한다.

```jsx
let arr = [1, 2, 3];
arr.includes(2); // true
arr.includes(6); // false
```

## find(fn)

함수의 조건식을 만족하는 첫번째 아이템에 대해 true를 반환한다. 없으면 undefinded을 반환한다. 배열에 객체가 들어있을 때 사용할 수 있다.

```jsx
let arr = [1, 2, 3, 4, 5];

const result = arr.find((item) => {
    return item % 2 === 0;
});

console.log(result);
```

## findIndex(fn)

```jsx
// find, findIndex
let userList = [
    {name: "Mike", age: 30},
    {name: "Jane", age: 27},
    {name: "Tom", age: 10},
]

const teen = userList.find((user) => {
    if (user.age < 19) {
        return true;
    } 
    return false;
})
console.log(teen); // { name: 'Tom', age: 10 }

const teen_index = userList.findIndex((user) => {
    if (user.age < 19) {
        return true;
    } 
    return false;
})
console.log(teen_index); // 2
```

## reverse()

```jsx
let arr = [1, 2, 3, 4, 5];
arr.reverse(); // [5, 4, 3, 2, 1]
```

## filter(fn)

만족하는 모든 요소를 배열로 반환한다.

```jsx
arr = [1, 2, 3, 4, 5, 6];
filtered_array = arr.filter((item) => {
    return item % 2 === 0;
})
console.log(filtered_array); // [ 2, 4, 6 ]
```

## map(fn)

아이템에 대해 함수를 실행하여 새로운 배열을 반환한다.

```jsx
userList = [
    {name: "Mike", age: 30},
    {name: "Jane", age: 27},
    {name: "Tom", age: 10},
];

let newUserList = userList.map((user, index) => {
    return Object.assign({}, user, {
        id: index + 1,
        isAdult: user.age > 19,
    })
});

console.log(newUserList);
/*
[
  { name: 'Mike', age: 30, id: 1, isAdult: true },
  { name: 'Jane', age: 27, id: 2, isAdult: true },
  { name: 'Tom', age: 10, id: 3, isAdult: false }
]
*/
```

## join(sep)

```jsx
arr = ["안녕", "나는", "철수야"];
const join_arr = arr.join('-');
console.log(join_arr); // 안녕-나는-철수야
```

## split(sep)

```jsx
arr = "안녕,나는,철수야";
const split_arr = arr.split(',');
console.log(split_arr); // [ '안녕', '나는', '철수야' ]
```

## isArray(obj)

typeof를 사용하면 객체든 배열이든 object를 반환한다. 이럴 때는 isArray()를 사용하여 배열 여부를 판단할 수 있다.

```jsx
// isArray()
let user = {
    name: "Mike",
    age: 30,
};
let users = ["Mike", "Tom", "Jane"];

console.log(typeof user); // object
console.log(typeof users);  // object

console.log(Array.isArray(user)); // false
console.log(Array.isArray(users)); // true
```

## sort(fn)

배열 값을 정렬할 수 있다.

```jsx
/*
arr.sort()
배열 재정렬
주의! 배열 자체가 변경됨
인수로 정렬 로직을 담은 함수를 받음
*/
let arr1 = [4, 6, 2, 3, 1];
let arr2 = ["a", "c", "d", "e", "b"];

arr1.sort();
arr2.sort();

console.log(arr1); // [ 1, 2, 3, 4, 6 ]
console.log(arr2); // [ 'a', 'b', 'c', 'd', 'e' ]
```

sort()는 별도의 함수를 전달하지 않으면 배열 아이템을 문자열로 취급한다. 정수를 크기 순으로 정렬하려면 정렬 로직을 따로 전달해야 한다.

```jsx
// 정렬 로직 전달
let arr3 = [27, 8, 5, 13];

// 8 27 5 13
// 5 8 27 13
// 5 8 13 27

function fn(a, b) {
    return a - b;
}

arr3.sort(fn);
console.log(arr3); // [ 5, 8, 13, 27 ]
```

귀찮으면 [Lodash 라이브러리](https://lodash.com/docs/4.17.15) 써도 된다.

## reduce(fn)

배열의 각 요소에 대해 주어진 리듀서 함수를 실행하고, 하나의 결과값을 반환한다.

```jsx
// 배열 값 모두 더하기
arr = [1, 2, 3, 4, 5];
sum = arr.reduce((prev, cur) => {
    return prev + cur;
}, 100)
console.log(sum); // 115
```

초기값을 빈 배열로 넘겨줘서 filter처럼 사용할 수도 있다.

```jsx
// 성인만 골라내기
userList = [
    {name: "Mike", age: 30},
    {name: "Jane", age: 27},
    {name: "Tom", age: 10},
];

let adultList = userList.reduce((prev, cur) => {
    if (cur.age > 19) {
        prev.push(cur);
    }
    return prev;
}, []);

console.log(adultList); // [ { name: 'Mike', age: 30 }, { name: 'Jane', age: 27 } ]
```